/* *****************************************************************************
 * File: phy_top.vp
 * Author: Ofer Shacham
 * 
 * Description:
 * This module is the absolute top of the design. It contains only two instances:
 * * design - this is the actual design that you made
 * * design_pad_wrapper - this is a wrapper for the instantiation of the IO pads
 * 
 * REQUIRED GENESIS PARAMETERS:
 * ----------------------------
 * * DesignName -- Which design do we build a phy top for?
 * 
 * 
 * Inputs:
 * -------
 * Inputs are identical to those of the main design (i.e. 'template'), except for 
 * inputs that regard the boundary scan and pads control
 * 
 * Outputs:
 * --------
 * Outputs are identical to those of the main design (i.e. 'template'), except for 
 * outputs that regard the boundary scan and pads control
 * 
 * Change bar:
 * -----------
 * Date          Author   Description
 * Mar 28, 2010  shacham  init version
 * May 18, 2010  shacham  Added orientation feild to IO parameter list
 * Apr 18, 2012  shacham  clean up of names and genesis syntactic sugar
 * 
 * ****************************************************************************/

// ACTUAL GENESIS2 PARAMETERIZATIONS
//; my $design_name = parameter(Name=>'DesignName', Val=>'', Doc=>"Which design do you want me to build a phy top for?");
//; $self->error("Missing value for parameter DesignName") if $design_name eq '';
//;
//; # This is a trick: we'll elaborate the main design first so that we can extract the IO list...
//; my $design_obj = generate($design_name,$design_name);
//;
//; # Now we can extract the interface name and the IO list:
//; my $ifc_path = $design_obj->get_param('IfcPtr');
//; my $ifc = clone($ifc_path, 'ifc');
//; my $io_list = $design_obj->get_param('IOList');
//; my $num_ios = scalar(@{$io_list});
//;
//; # this would enable others to use this interface
//; parameter(Name=>'IfcPtr', Val=>$ifc, force=>1, Doc=>"Declaring our interface object for others to use");
//;
//; # Verify correctness of IO parameters:
//; my $cnt = 0;
//; foreach my $io (@{$io_list}){
//;   $self->error("IO $cnt is missing it's name!") 
//;	unless defined $io->{name};
//;   $self->error("IO $io->{name} (IO\# $cnt) is missing its width!") 
//;	unless defined $io->{width};
//;   $self->error("IO $io->{name} (IO\# $cnt) has an illegal width -->$io->{width}<--!") 
//;	if ($io->{width} < 1);
//;   $self->error("IO $io->{name} (IO\# $cnt) is missing its direction!") 
//;	unless defined $io->{direction};
//;   $self->error("IO $io->{name} (IO\# $cnt) has an invalid direction -->$io->{direction}<--! ".
//;		   "(allowed values: in/out)") 
//;	unless ($io->{direction} =~ m/^(in|out)$/i);
//;   $self->error("IO $io->{name} (IO\# $cnt) does not specify whether it's on the boundary scan!") 
//;	unless defined $io->{bsr};
//;   $self->error("IO $io->{name} (IO\# $cnt) has an invalid bsr flag -->$io->{bsr}<--! ".
//;		   "(allowed values: yes/no)") 
//;	unless ($io->{bsr} =~ m/^(yes|no)$/i);
//;   $self->error("IO $io->{name} (IO\# $cnt) does not specify pad type (analog/digital)!") 
//;	unless defined $io->{pad};
//;   $self->error("IO $io->{name} (IO\# $cnt) has an invalid pad flag -->$io->{pad}<--! ".
//;		   "(allowed values: analog/digital)") 
//;	unless ($io->{pad} =~ m/^(anl|analog|dig)/i);
//;   $self->error("IO $io->{name} (IO\# $cnt) does not specify pad orientation (left, right, top, bottom)!") 
//;	unless defined $io->{orientation};
//;   $self->error("IO $io->{name} (IO\# $cnt) has an invalid pad orientation -->$io->{orientation}<--!".
//;		   "(allowed values: left, right, top, bottom)") 
//;	unless ($io->{orientation} =~ m/^(left|right|top|bottom)$/i);
//;   $cnt++;
//; } # end of "foreach my $io..."
//;
//;
//; include ("analog_defs.vph");


module `mname`
  (
   `$ifc->instantiate` 
   );

   // Special signals comming out of the pwrap
   logic pwrap_Clk;
   logic pwrap_Reset;
   
   
   // Signals connecting BSR from/to design to/from pad wrapper
   logic 				bsr_tdi;
   logic 				bsr_tdo;
   logic 				bsr_sample;
   logic 				bsr_intest;
   logic 				bsr_extest;
   logic 				bsr_update_en;
   logic 				bsr_capture_en;
   logic 				bsr_shift_dr;


   // make an interface to connect the design to the pwrap
   //; my $pad2des_ifc = clone($ifc, 'pad2des_ifc');
   `$pad2des_ifc->instantiate` (.Clk(pwrap_Clk), .Reset(pwrap_Reset));

   
   // instantiation of main design
   `$design_obj->instantiate` (
				.ifc(`$pad2des_ifc->iname`.des),
				
				// BSR Signals
				.bsr_tdi(bsr_tdi),
				.bsr_tdo(bsr_tdo),
				.bsr_sample(bsr_sample),
				.bsr_intest(bsr_intest),
				.bsr_extest(bsr_extest),
				.bsr_update_en(bsr_update_en),
				.bsr_capture_en(bsr_capture_en),
				.bsr_shift_dr(bsr_shift_dr)
				);
   

   // Instantiation of pads wrapper
   //; my $pad_wrapper_inst = generate('pad_wrapper', 'pad_wrapper',
   //;				       IOList => $io_list );
   `$pad_wrapper_inst->instantiate`(
				    .ext_ifc(`$ifc->iname`.des),
				    .des_ifc(`$pad2des_ifc->iname`.pwrap),
				    .ext2des_Clk(pwrap_Clk),
				    .ext2des_Reset(pwrap_Reset),
				    
				    // BSR Signals
				    .bsr_tdi(bsr_tdi),
				    .bsr_tdo(bsr_tdo),
				    .bsr_sample(bsr_sample),
				    .bsr_intest(bsr_intest),
				    .bsr_extest(bsr_extest),
				    .bsr_update_en(bsr_update_en),
				    .bsr_capture_en(bsr_capture_en),
				    .bsr_shift_dr(bsr_shift_dr)
				    );


endmodule : `mname`
