/* *****************************************************************************
 * File: pad.vp
 * 
 * Description:
 *
 * 
 * Required Genesis2 Controlable Parameters:
 * * Type		- 'analogIn', 'analogOut', 'coreVDD' , 'coreVSS', 'ioVDD' , 'ioVSS' , 'digIn' , 'digOut'  
 *
 * ****************************************************************************/


/*******************************************************************************
 * REQUIRED PARAMETERIZATION
 ******************************************************************************/
//; use POSIX ;
//; use Switch ;
//;
//; my $Type = parameter(Name=>'Type', Val=>"", 
//;			      List=>[ 'analogIn', 'analogOut', 
//;                                   'coreVDD' , 'coreVSS', 
//;                                   'ioVDD'   , 'ioVSS' , 
//;                                   'digIn'   , 'digOut'  ],
//;			      Doc=>'Type of pad: ');
//; my $workAround = 1 ;
//; include ("analog_defs.vph");
//;

module `mname`(
//;
//;            my $inputType = $Type =~ m/analog/ ? $input_real : 'input logic' ;
//;            my $outputType = $Type =~ m/analog/ ? $output_real : 'output logic' ;
//;
//;	       if( $Type =~ m/In/ ){
    		     `$inputType`  fromboard ,
	             `$outputType` tochip    
//;	       }
//;	       if( $Type =~ m/Out/ ){
    		    `$outputType`  toboard ,
	            `$inputType`   fromchip 
//;	       }
//;            if(  $Type =~ m/dig/  ){
                    , input logic   en 
//;            }

);

//
// LIST OF 90nm Pads
// module A1825(PADIO,VDDIO,VDD,VSSIO,VSS,CORE);
// module AR1825(PADIO,VDDIO,VDD,VSSIO,VSS,CORE);
// module AVDD(VDD,VSSIO,AVDD,VSS);
// module AVSS(VDDIO,VDD,AVSS,VSSIO,VSS);
// module BONDPAD(PADIO,VSS,VDDIO,VDD,VSSIO);
// module BREAKCORE(VSS,VDDIO,VDD,VSSIO);
// module CAPCORNER(VSS,VDDIO,VDD,VSSIO);
// module CIOVDDIOVSS(VSS,VDDIO,VDD,VSSIO);
// module CORNER(VSS,VDDIO,VDD,VSSIO);
// module CVDDVSS(VSS,VDDIO,VDD,VSSIO);
// module D12I1025(PADIO,VSS,EN,VDDIO,VDD,VSSIO,DIN);
// module D16I1025(PADIO,VSS,PULL_UP,VDDIO,EN,VDD,VSSIO,DIN,PULL_DOWN);
// module D2I1025(PADIO,VSS,EN,VDDIO,VDD,VSSIO,DIN);
// module D4I1025(PADIO,VSS,EN,VDDIO,VDD,VSSIO,DIN);
// module D8I1025(PADIO,VSS,EN,VDDIO,VDD,VSSIO,DIN);
// module DIOVSSVSS(VSS,VDDIO,VDD,VSSIO);
// module I1025(PADIO,VSS,VDDIO,VDD,R_EN,VSSIO,DOUT);
// module IOVDD(VSS,VDDIO,VDD,VSSIO);
// module IOVSS(VSS,VDDIO,VDD,VSSIO);
// module ISH1025(PADIO,VSS,VDDIO,VDD,R_EN,VSSIO,DOUT);
// module VDD(VSS,VDDIO,VDD,VSSIO);
// module VSS(VSS,VDDIO,VDD,VSSIO);
//
   
//;
//; if( $mode eq 'Synth' ){  
//;   
//; switch( $Type ) {
//;
//;
//;     case 'analogIn' {
//;

   
//               A1825 A1825_pad_local(fromboard,tochip);
   assign tochip = fromboard ;
   
   
//;    
//;     }
//;     case 'analogOut' {
//;

   
 //              A1825 A1825_pad_local(toboard,fromchip);
   assign toboard = fromchip ;
   
   
//;    
//;     }
//;     case 'coreVDD' {
//;

   
    //           VDD VDD_pad_local();

   
//;    
//;     }
//;     case 'coreVSS' {
//;

   
   //            VSS VSS_pad_local();

   
//;    
//;     }
//;     case 'ioVDD' {
//;

   
    //           IOVDD iovss_padlocal() ;

   
//;    
//;     }
//;     case 'ioVSS' {
//;

   
      //         IOVSS iovdd_padlocal() ;

   
//;    
//;     }
//;     case 'digIn' {
//;


      //         I1025 I1025_pad_local(fromboard,en,tochip);
   assign tochip = en ? fromboard : 1'bz ;
   

//;    
//;     }
//;     case 'digOut' {
//;

   //            D2I1025 D2I1025_pad_local(toboard,en,fromchip);
   assign toboard = en? fromchip : 1'bz ;
      
//;  
//;     }
//;     else {
//;
//;            $self->error( "Unknown pad-type...\n" ) ;
//;
//;     }
//; } #END SWITCH ON TYPE
//;
//; } elsif( $mode eq 'Sim' ) { #END if synth mode
//;
//;       if( $Type =~ m/analog/ ){
//;

   logic 	     en ;
   assign            en = 1'b1 ;
   
//;
//;       }
//;
//;	  if( $Type =~ m/In/ ){
//;
   
                assign tochip = en ? fromboard : 1'bz;

//;
//;	  }
//;	  if( $Type =~ m/Out/ ){
//;

                assign toboard = en ? fromchip : 1'bz;

//;
//;	  }
//;
//;
//; } else { #END if Sim mode
//;
//;     $self->error( "Unknown mode: $mode\n" );
//;
//; }
//;
   
endmodule : `mname`