/* *****************************************************************************
 * File: pad_wrapper.vp
 * Author: Ofer Shacham
 * 
 * Description:
 * This module is a wrapper for the instantiation of the IO pads.
 * It's purposes are:
 * * To stitch the boundary scan register
 * * To generate bsr.vh that can be used to assist in testing the bsr
 * * To instantiate all the IO, Vdd and Gnd pads
 * * To generate the Top Design Forma file for place and route tools
 * 
 * Comment:
 * The pad wrapper has two main interfaces: ext_ifc and des_ifc. ext_ifc is 
 * simply a propagation of the phy_top interface. des_ifc, is an interface from
 * the wrapper to the design itself.
 * 
 *        ----------------------------------------------------------------------		
 *        |phy_top                                                             |
 *        |	   -----------------------         -----------------------     |
 *        |	   |     pad_wrapper     |         |        design       |     |
 *      --->sig_in--->	      	       --->sig_in--->                    |     |
 *        |	   |ext_ifc       des_ifc|         |                     |     |
 *     <---sig_out<---                 <---sig_out<---                   |     |
 *        |	   |                     |         |                     |     |
 *        |	   -----------------------         -----------------------     |
 *        |                                                                    |
 *        |                                                                    |
 *        ----------------------------------------------------------------------	
 * For each input to the design, X_in: there is an input to the pad_wrapper, 
 * ext_ifc.X_in, that comes directly from the phy top. Then, des_ifc.X_in, 
 * connects to the original input, to the actual design.
 * For an output of the design Y_out, pad_wrapper would have an input named 
 * des_ifc.Y_out that connects the design port and the pad wrapper. Then,
 * pad_wrapper would also have an output port ext_ifc.Y_out that goes out 
 * through the top level.
 * 
 * NOTE: It is assumed that the Clk and Reset pad always exists in all designs.
 *       Furthermore, it is assumed that they reside in the top side of the chip,
 *       adjacent to the top-right corner. Why? No good reason.
 *
 * REQUIRED GENESIS PARAMETERS:
 * ----------------------------
 * * IOList -  List of main design IOs. For each IO you must specify:
 *   * name
 *   * width
 *   * direction - allowed directions are 'in'/'out'
 *   * pad - Whether the pad would be digital or analog (allowed values are
 *		'digital'/'anlog'). 
 *   * bsr - Whether this IO is on the boundary scan register (allowed values are
 *		'yes'/'no'). 
 *		Note: JTAG signals must not be on the BSR since they are used 
 *		      to read the BSR.
 *   * orientation - Orientation of the IO pad. allowed values are {left, right, 
 *		     top, bottom}
 * * NUM_CORE_VDD_PINS - number of required core vdd pins. Note that this implies
 *			 same number of core gnd pins. pins are placed uniformly
 *			 around the perimeter. Default value is arbitatily choosen
 *			 to be 10 (10 Vdd and 10 Gnd)
 * * RATIO_IO_VDD__IN_PINS - Ratio of IO power supply pins to input signals. 
 *			       Coosen by Jim Weaver to be 8 by default
 * * RATIO_IO_VDD__OUT_PINS - Ratio of IO power supply pins to input signals. 
 *			        Coosen by Jim Weaver to be 4 by default
 * * TDF_FILE_NAME - Name of the Top Design Format to be generated 
 *		     (default is 'pads.tdf')
 * * BSR_TEST_FILE_NAME - Name of header file to be generated for the BSR 
 *			  testbench. (default is bsr_test.vh)
 * 
 * Inputs:
 * -------
 * Inputs are identical to those of the main design (i.e. 'template'), plus  
 * inputs that regard the boundary scan and pads control
 * 
 * Outputs:
 * --------
 * Outputs are identical to those of the main design (i.e. 'template'), plus 
 * outputs that regard the boundary scan and pads control
 * 
 * Change bar:
 * -----------
 * Date          Author   Description
 * Mar 28, 2010  shacham  init version  --  
 * May 18, 2010  shacham  stiched the BSR chain. Also added 'orientation' field 
 *			  to all IO's in order to generate the Top Design Format 
 *			  (TDF) file for PNR
 * May 20, 2010  shacham  Added support for instantiation of core vdd/gnd
 * 
 * 
 * FIXME: 
 * -------
 * * There are no analog pads instantiated at this point!!!
 * 
 * ****************************************************************************/

//; # A couple of required perl libs for manipulating files
//; use FileHandle;
//; use File::Basename;
//; use POSIX;
//;
// GENESIS2 PARAMETERIZATIONS
//; my $my_inst_name = $self->iname;
//; my $io_list = parameter(Name=>'IOList', Val=>[]);
//; my $num_ios = scalar(@{$io_list});
//;
//;# Verify correctness of IO parameters:
//; $self->error("IOList is empty") 
//;   unless ($num_ios > 0);
//;
//; my $cnt = 0;
//; foreach my $io (@{$io_list}){
//;   $self->error("IO $cnt is missing it's name!") 
//;	unless defined $io->{name};
//;   $self->error("IO $io->{name} (IO\# $cnt) is missing its width!") 
//;	unless defined $io->{width};
//;   $self->error("IO $io->{name} (IO\# $cnt) has an illegal width -->$io->{width}<--!") 
//;	if ($io->{width} < 1);
//;   $self->error("IO $io->{name} (IO\# $cnt) is missing its direction!") 
//;	unless defined $io->{direction};
//;   $self->error("IO $io->{name} (IO\# $cnt) has an invalid direction -->$io->{direction}<--!".
//;		   "(allowed values: in/out)") 
//;	unless ($io->{direction} =~ m/^(in|out)$/i);
//;   $self->error("IO $io->{name} (IO\# $cnt) does not specify whether it's on the boundary scan!") 
//;	unless defined $io->{bsr};
//;   $self->error("IO $io->{name} (IO\# $cnt) has an invalid bsr flag -->$io->{bsr}<--!".
//;		   "(allowed values: yes/no)") 
//;	unless ($io->{bsr} =~ m/^(yes|no)$/i);
//;   $self->error("IO $io->{name} (IO\# $cnt) does not specify pad type (analog/digital)!") 
//;	unless defined $io->{pad};
//;   $self->error("IO $io->{name} (IO\# $cnt) has an invalid pad flag -->$io->{pad}<--!".
//;		   "(allowed values: analog/digital)") 
//;	unless ($io->{pad} =~ m/^(anl|analog|dig)/i);
//;   $self->error("IO $io->{name} (IO\# $cnt) does not specify pad orientation (left, right, top, bottom)!") 
//;	unless defined $io->{orientation};
//;   $self->error("IO $io->{name} (IO\# $cnt) has an invalid pad orientation -->$io->{orientation}<--!".
//;		   "(allowed values: left, right, top, bottom)") 
//;	unless ($io->{orientation} =~ m/^(left|right|top|bottom)$/i);
//;   $cnt++;
//; } # end of "foreach my $io..."
//;
//;
//; # NUM_CORE_VDD_PINS * * RATIO_IO_VDD__IN_PINS * * RATIO_IO_VDD__OUT_PINS
//; my $num_core_vdd_pins = $self->define_param(NUM_CORE_VDD_PINS => 10);
//; my $ratio_io_vdd__in_pins = $self->define_param(RATIO_IO_VDD__IN_PINS => 8);
//; my $ratio_io_vdd__out_pins = $self->define_param(RATIO_IO_VDD__OUT_PINS => 4);
//;
//; # Let's open a TDF (Top Design Format) file and dump all our 
//; # knowladge into it
//; my $tdf_fn = $self->define_param(TDF_FILE_NAME => 'pads.tdf');
//; my $tdf_fh = new FileHandle;
//; open($tdf_fh, ">$tdf_fn") ||
//;      $self->error("Couldn't open TDF file $tdf_fn: $@");
//;
//;
//; # Let's open a BSR header file that would later help in testing
//; my $bsr_fn = $self->define_param(BSR_TEST_FILE_NAME => 'bsr_test.vh');
//; my $bsr_fh = new FileHandle;
//; open($bsr_fh, ">$bsr_fn") ||
//;      $self->error("Couldn't open BSR header file $bsr_fn: $@");
//;
//; include ("analog_defs.vph");



module `mname`  (
		 // main IOs
		 interface ext_ifc, 
		 interface des_ifc,
		 
		 // special IOs
		 output logic ext2des_Clk,
		 output logic ext2des_Reset,
		 
		 //   BSR control signals
		 input 	logic bsr_tdi,
		 input 	logic bsr_sample,
		 input 	logic bsr_intest,
		 input 	logic bsr_extest,
		 input 	logic bsr_update_en,
		 input 	logic bsr_capture_en,
		 input 	logic bsr_shift_dr,
		 output logic bsr_tdo 
		 );

    					
   
   
   //; #########################################################################
   //; # Let's prepare and re-order the IO list:
   //; #########################################################################
   //; my $num_bsrs = 0;
   //; my $num_pins = 0;
   //; my $io_list_left = [];
   //; my $io_list_right = [];
   //; my $io_list_top = [];
   //; my $io_list_bottom = [];
   //; foreach my $io (@{$io_list}){
   //;   push(@{$io_list_left}, $io) if ($io->{orientation} =~ m/^left$/i);
   //;   push(@{$io_list_right}, $io) if ($io->{orientation} =~ m/^right$/i);
   //;   push(@{$io_list_top}, $io) if ($io->{orientation} =~ m/^top$/i);
   //;   push(@{$io_list_bottom}, $io) if ($io->{orientation} =~ m/^bottom$/i);
   //;
   //;   # count the number of BSR signals:
   //;   $num_bsrs++ if ($io->{bsr} =~ m/yes/i);
   //;   # count the number of pins:
   //;   $num_pins = $num_pins+$io->{width};
   //; }
   //;
   //; # reassign the io_list pointer
   //; $io_list = [];
   //; push(@{$io_list}, @{$io_list_right}, @{$io_list_bottom}, 
   //;			 @{$io_list_left}, @{$io_list_top});
   //;
   //;
   //; #########################################################################
   //; # Let's prepare some power and ground procedures:
   //; #########################################################################
   //; # frequency of core gnd/vdd pins:
   //; my $core_vdd_frq = POSIX::floor($num_pins/($num_core_vdd_pins*2));
   //; my $core_tgl = 'vdd';
   //;
   //; # general counters and state variables
   //; my $pin_cnt = 0;
   //; my $orientation = ${$io_list}[0]->{orientation};
   //;
   //; # Define a function to instantiate the core vdd/gnd
   //; sub add_core_vdd_or_gnd{
   //;   if ($pin_cnt % $core_vdd_frq == 0){
   //;     if ($core_tgl =~ m/vdd/){
   //;       my $vdd_name = "pad_core_vdd_" . ($pin_cnt/(2*$core_vdd_frq)) ;
   //;       my $padVddCore = generate( "pad" , $vdd_name , Type=>'coreVDD' );

             `$padVddCore->instantiate`();
   
   //;       print {$tdf_fh} "pad \"${my_inst_name}/$vdd_name\" \"$orientation\" FIXME:999\n";
   //;       print {$tdf_fh} "tdfSetMinIOSpacing \"${my_inst_name}/$vdd_name\" 0 0 0 0\n";
   //;       $core_tgl = 'gnd';
   //;     }else{
   //;       my $vss_name = "pad_core_gnd_" . (($pin_cnt-$core_vdd_frq)/(2*$core_vdd_frq)) ;
   //;       my $padVSSCore = generate( "pad" , $vss_name , Type=>'coreVSS' );

             `$padVSSCore->instantiate`();

   //;       print {$tdf_fh} "pad \"${my_inst_name}/$vss_name\" \"$orientation\" FIXME:999\n";
   //;       print {$tdf_fh} "tdfSetMinIOSpacing \"${my_inst_name}/$vss_name\" 0 0 0 0\n";
   //;       $core_tgl = 'vdd';
   //;     }
   //;   }
   //; } # end of "sub add_core_vdd..."
   //;
   //;
   //; #########################################################################
   //; # Now let's build the needed hardware
   //; #########################################################################
   //; my $bsr_cnt = 0;
   //; my $prevsig = "bsr_tdi";
   //; foreach my $io (@{$io_list}){
   //;   $orientation = $io->{orientation};
   //;########################################################
   //;## ANALOG
   //;########################################################
   //;   if ($io->{pad} =~ m/^(anl|analog)/i){
   //;       my $dir = $io->{direction} =~ m/^in$/i ? 1 : ($io->{direction} =~ m/^out$/i ? 0 : -1 ) ;
   //;       $dir == -1 and $self->error("Direction is neither in or out...\n" );
   //;       my $analog_name = "pad_analog_" . $io->{direction} . "_" . $io->{name} ;
   //;       my $analog_pad = generate( "pad" , $analog_name , Type=>($dir?'analogIn':'analogOut') );

             `$analog_pad->instantiate`(ext_ifc.`$io->{name}`,des_ifc.`$io->{name}`);

   //;       print {$tdf_fh} "pad \"${my_inst_name}/$analog_name\" \"$orientation\" FIXME:999\n";
   //;       print {$tdf_fh} "tdfSetMinIOSpacing \"${my_inst_name}/$analog_name\" 0 0 0 0\n";
   //;       next;
   //;   } # end of "if ($io->{pad} =~ m/^(an..."
   //;
   //;########################################################
   //;## DIGITAL, NON BSR
   //;########################################################
   //;   if ($io->{bsr} =~ m/no/i){
   //;########################################
   //;## DIGITAL, NON BSR, INPUTS 
   //;########################################
   //;     if ($io->{direction} =~ m/^in$/i){
   
   // Pads (Only) For Digital Input: `$io->{name}`
   //;       for (my $idx=0; $idx < $io->{width} ; $idx++){
   //;         my $sig = $io->{name}."_".$idx;     
   //;         my $digital_name = "pad_analog_" . $io->{direction} . "_" . $io->{name}  . "_" . $idx ;
   //;         my $digital_pad = generate( "pad" , $digital_name , Type=>'digIn' );

               `$digital_pad->instantiate`( ext_ifc.`$io->{name}``$io->{width}>1?"[$idx]":""` ,
					    des_ifc.`$io->{name}``$io->{width}>1?"[$idx]":""` ,
					    1'b1 );
 
   //;	       $self->add_core_vdd_or_gnd();
   //;         $pin_cnt++;
   //;
   //;	       # print to TDF file
   //;         print {$tdf_fh} "pad \"${my_inst_name}/$digital_name\" \"$orientation\" FIXME:999\n";
   //;         print {$tdf_fh} "tdfSetMinIOSpacing \"${my_inst_name}/$digital_name\" 0 0 0 0\n";
   //;       } # end of "for (my $idx=0..."
   //;	   } # end of "if ($io->{direc..."
   //;
   //;########################################
   //;## DIGITAL, NON BSR, OUTPUTS 
   //;########################################
   //;     if ($io->{direction} =~ m/^out$/i){
   
   // Pads (Only) For Digital Output: `$io->{name}`
   //;       for (my $idx=0; $idx < $io->{width}; $idx++){
   //;         my $sig = $io->{name}."_".$idx;
   //;         my $digital_name = "pad_analog_" . $io->{direction} . "_" . $io->{name}  . "_" . $idx ;
   //;         my $digital_pad = generate( "pad" , $digital_name , Type=>'digOut' );

               `$digital_pad->instantiate`( ext_ifc.`$io->{name}``$io->{width}>1?"[$idx]":""` ,
					    des_ifc.`$io->{name}``$io->{width}>1?"[$idx]":""` ,
					    1'b1 );

   
   //;   
   //;	       $self->add_core_vdd_or_gnd();
   //;         $pin_cnt++;
   //;
   //;	       # print to TDF file
   //;         print {$tdf_fh} "pad \"${my_inst_name}/}$digital_name\" \"$orientation\" FIXME:999\n";
   //;         print {$tdf_fh} "tdfSetMinIOSpacing \"${my_inst_name}/$digital_name\" 0 0 0 0\n";
   //;       } # end of "for (my $idx=0..."
   //;	   } # end of "if ($io->{direc..."
   //;     next;
   //;   } # end of "if ($io->{bsr} =~ m/no..."
   //;
   //;
   //;########################################################
   //;## DIGITAL, BSR
   //;########################################################
   //;########################################
   //;## DIGITAL, BSR, INPUTS 
   //;########################################
   //;   if ($io->{direction} =~ m/^in$/i){
   
   // Boundary Scan Regs and Pads For Digital Input: `$io->{name}`
   //;     for (my $idx=0; $idx < $io->{width}; $idx++){
   //;       my $sig = $io->{name}."_".$idx;
   logic 				pad2reg_`$sig`;
   //;       my $nextsig = "bsr_".$sig."_so";
   //;	     if ($bsr_cnt==$num_bsrs-1 && $idx==$io->{width}-1){
   //;         $nextsig = "bsr_tdo";
   //;       }else{
   logic 				`$nextsig`;
   //;       }
               DW_bc_2 bsr_`$sig` (
				   .mode(bsr_intest),
				   .capture_clk(des_ifc.tck),
				   .update_clk(des_ifc.tck),
				   .update_en(bsr_update_en),
				   .capture_en(bsr_capture_en),
				   .shift_dr(bsr_shift_dr),
				   .data_in(pad2reg_`$sig`),	// From pad pad_`$sig` 
				   .data_out(des_ifc.`$io->{name}``$io->{width}>1?"[$idx]":""`),	// To the design signal
				   .si(`$prevsig`),
				   .so(`$nextsig`)
				   );

   //;         my $digital_name = "pad_digital_" . $io->{direction} . "_" . $io->{name} . "_" . $idx ;
   //;         my $digital_pad = generate( "pad" , $digital_name , Type=>'digIn' );
               `$digital_pad->instantiate`( ext_ifc.`$io->{name}``$io->{width}>1?"[$idx]":""` ,
					    pad2reg_`$sig` ,
					    1'b1 );
   
   
   //;       $prevsig = "bsr_".$sig."_so";
   //;	     $self->add_core_vdd_or_gnd();
   //;       $pin_cnt++;
   //;
   //;       # print to TDF file
   //;       print {$tdf_fh} "pad \"${my_inst_name}/$digital_name\" \"$orientation\" FIXME:999\n";
   //;       print {$tdf_fh} "tdfSetMinIOSpacing \"${my_inst_name}/$digital_name\" 0 0 0 0\n";
   //;     } # end of "for (my $idx=0; ..."
   //;   } # end of "if ($io->{di..."
   //;
   //;
   //;########################################
   //;## DIGITAL, BSR, OUTPUTS 
   //;########################################
   //;   if ($io->{direction} =~ m/^out$/i){

   // Boundary Scan Regs and Pads For Digital Output: `$io->{name}`
   //;     for (my $idx=0; $idx < $io->{width}; $idx++){
   //;       my $sig = $io->{name}."_".$idx;
   logic 				reg2pad_`$sig`;
   //;       my $nextsig = "bsr_".$sig."_so";
   //;	     if ($bsr_cnt==$num_bsrs-1 && $idx==$io->{width}-1){
   //;         $nextsig = "bsr_tdo";
   //;       }else{
   logic 				`$nextsig`;
   //;       }
   DW_bc_2 bsr_`$sig` (
		       .mode(bsr_extest),
		       .capture_clk(des_ifc.tck),
		       .update_clk(des_ifc.tck),
		       .update_en(bsr_update_en),
		       .capture_en(bsr_capture_en),
		       .shift_dr(bsr_shift_dr),
		       .data_in(des_ifc.`$io->{name}``$io->{width}>1?"[$idx]":""`),	// From design signal `$io->{name}`[`$idx`] 
		       .data_out(reg2pad_`$sig`),	// Sent to the pad
		       .si(`$prevsig`),
		       .so(`$nextsig`)
		       );
   //;         my $digital_name = "pad_digital_" . $io->{direction} . "_" . $io->{name}  . "_" . $idx ;
   //;         my $digital_pad = generate( "pad" , $digital_name , Type=>'digOut' );
               `$digital_pad->instantiate`( ext_ifc.`$io->{name}``$io->{width}>1?"[$idx]":""` ,
					    reg2pad_`$sig` ,
					    1'b1);

   
   //;       $prevsig = "bsr_".$sig."_so";
   //;	     $self->add_core_vdd_or_gnd();
   //;       $pin_cnt++;
   //;
   //;       # print to TDF file
   //;       print {$tdf_fh} "pad \"${my_inst_name}/pad_${sig}\" \"$orientation\" FIXME:999\n";
   //;       print {$tdf_fh} "tdfSetMinIOSpacing \"${my_inst_name}/pad_${sig}\" 0 0 0 0\n";
   //;     } # end of "for (my $idx=0; ..."
   //;   } # end of "if ($io->{di..."
   //;
   //;   $bsr_cnt++;
   //; } # end of "foreach my $io..."

   //;
   //; ##special IOs
   //; #clk 
   //; my $digital_clk_name = "pad_digital_Clk" ;
   //; my $digital_clk_pad = generate( "pad" , $digital_clk_name , Type=>'digIn' );
   //;
   
   `$digital_clk_pad->instantiate`( ext_ifc.Clk,ext2des_Clk ,1'b1);  

   //;
   //; $self->add_core_vdd_or_gnd();
   //; $pin_cnt++;
   //;
   //; # print to TDF file
   //; print {$tdf_fh} "pad \"${my_inst_name}/$digital_clk_name\" \"$orientation\" FIXME:999\n";
   //; print {$tdf_fh} "tdfSetMinIOSpacing \"${my_inst_name}/$digital_clk_name\" 0 0 0 0\n";
   //;
   //; #clk 
   //; my $digital_rst_name = "pad_digital_rst" ;
   //; my $digital_rst_pad = generate( "pad" , $digital_rst_name , Type=>'digIn' );
   //;
   
       `$digital_rst_pad->instantiate`(ext_ifc.Reset,ext2des_Reset,1'b1 );  

   //;
   //; $self->add_core_vdd_or_gnd();
   //; $pin_cnt++;
   //;
   //; # print to TDF file
   //; print {$tdf_fh} "pad \"${my_inst_name}/$digital_rst_name\" \"$orientation\" FIXME:999\n";
   //; print {$tdf_fh} "tdfSetMinIOSpacing \"${my_inst_name}/$digital_rst_name\" 0 0 0 0\n";
   //;

endmodule // `mname`

//; # Now close the files
//; close $tdf_fh if defined $tdf_fh;
//; close $bsr_fh if defined $bsr_fh;
